    (* EXPORT START *)
    fun key_val_store () = 
        let fun remove element list = 
            case list of 
            [] => []
            | h :: t => 
                if h = element then t
                else append [h] (remove element t)
        fun get_record key dic =
            case dic of
                [] => ()
                | h :: t => 
                    if h.key = key then h
                    else get_record key t
        fun get key dic = 
            let val record = get_record key dic
            in if record = () then ()
                else record.value
            end
        fun set (key, value) dic = 
            let val existing_record = get_record key dic 
                val new_record = {key = key, value = value}
            in if existing_record = () then 
                append [{key = key, value = value}] dic
            else 
                if new_record = existing_record then dic
                else append [new_record] (remove existing_record dic)
            end
        fun drop key dic = 
            remove (get_record key dic) dic
        val dic = []
        fun loop dic = 
            let val dic = receive [
                hn ("SET", (key, value)) => set (key, value) dic,
                hn ("GET", (key, sender_id)) => 
                    let val _ = send(sender_id, ("RESPONSE", (get key dic)))
                    in dic
                    end,
                hn ("GET_SNAPSHOT", sender_id) => 
                    let val _ = send(sender_id, ("SNAPSHOT", dic))
                    in dic
                    end,
                hn ("SET_SNAPSHOT", other_dic) => loop other_dic,
                hn ("SNAPSHOT_CONDITION", (log_summary, sender_id)) => 
                    let val callback = log_summary.committed_log_size > (length dic) 
                        andalso log_summary.entries_since_snap > 50
                    in 
                        send(sender_id, ("SNAPSHOT-CALLBACK", callback));
                        loop dic end,
                hn ("DROP", key) => drop key dic
            ]
            in loop dic
            end
        in loop dic
    end
    (* EXPORT END *)
