let (*EXPORT START*)
    fun countdown p_id time nonce = 
        sleep time;
        send(p_id, ("TIMEOUT", nonce))
    
    (* Maybe we keep track of all state changes and then send them as messages? *)
    fun passive_counter state_changes =
        let val nonce = mkuuid()
            val p_id = self()
        in receive [
            ("TIMEOUT", x) when x = nonce => 
                passive_counter (append state_changes ("INCREMENT-COUNTER")),
            ("REQUEST-CHANGES", callback_pid) => 
                send(callback_pid, state_changes); 
                passive_counter [],
            ("SHUTDOWN") => () 
        ]
    end

    (* Should we wait to apply the log until we are promoted as a leader, or
    have some side-effect-less version of the function? *)
    fun counter_transition_func cur_state input =
        case input of
        ("INCREMENT-COUNTER") => x + 1
        | ("GET", p_id) => send(p_id, x)
        | ("SET", x) => x
    