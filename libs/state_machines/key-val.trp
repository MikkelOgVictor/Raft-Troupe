    (* EXPORT START *)
    fun key_val_store dic = 
        let fun remove element list = 
            case list of 
            [] => []
            | h :: t => 
                if h = element then t
                else append [h] (remove element t)
        fun get_record key dic =
            case dic of
                [] => ()
                | h :: t => 
                    if h.key = key then h
                    else get_record key t
        fun get key dic = 
            let val record = get_record key dic
            in if record = () then ()
                else record.value
            end
        fun set (key, value) dic = 
            let val existing_record = get_record key dic 
                val new_record = {key = key, value = value}
            in if existing_record = () then 
                append [{key = key, value = value}] dic
            else 
                if new_record = existing_record then dic
                else append [new_record] (remove existing_record dic)
            end
        fun drop key dic = 
            remove (get_record key dic) dic
        fun loop dic = 
            let val dic = receive [
                hn ("SET", (key, value)) => set (key, value) dic,

                hn ("GET", (key, sender_id)) => 
                    send(sender_id, ("RESPONSE", (get key dic)));
                    dic,
                hn ("GET_STATE", sender_id) => 
                    send(sender_id, ("SNAPSHOT", dic));
                    dic,

                hn ("SNAPSHOT_CONDITION", (log_summary, sender_id)) => 
                    let val callback = log_summary.applied_log_size > (length dic) 
                        andalso log_summary.entries_since_snap > 50
                    in 
                        send(sender_id, ("SNAPSHOT_CALLBACK", callback));
                        dic end,

                hn ("DROP", key) => drop key dic
            ]
            in loop dic
            end
        in loop dic
    end

    val key_val_store_hooks = 
        {sethook = (fn x => case x of (key, value) => ("SET", (key, value))), 
            gethook = (fn (x, callback_pid) => ("GET", (x, callback_pid))), 
            get_snapshot_hook = (fn (callback_pid) => ("GET_STATE", callback_pid)),
            snapshot_condition_hook = (fn (log_summary, callback_pid) => ("SNAPSHOT_CONDITION", (log_summary, callback_pid)))}
    (* EXPORT END *)