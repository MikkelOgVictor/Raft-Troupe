    (* EXPORT START *)
    (* Creates a snapshot *)
    fun set_snapshot snapshot index term = {
        snapshot = snapshot,
        lastIncludedIndex = index,
        lastIncludedTerm = term
    }

    (* Creates a default, empty snapshot *)
    val empty_snapshot = set_snapshot () 0 0

    (* A default, empty log*)
    val empty_log = {
        log = [],
        snapshot = empty_snapshot,
        lastApplied = 0,
        commitIndex = 0,
        internalChanges = 0,
        lastMessageSerial = ""
    }

    fun pretty_print_log id log = 
        printString "\n========******========";
        printString ("ID: "^id);
        printString "----------------------";
        printString "Entries (term, message):";
        map (fn x => print (x.term, x.command)) log.log;
        printString "----------------------";
        printString "CommitIndex:";
        print log.commitIndex;
        printString "LastApplied:";
        print log.lastApplied;
        printString "Internal Changes:";
        print log.internalChanges;
        printString "----------------------";
        printString "Snapshot:";
        print log.snapshot;
        printString "========******========\n"

    (* Appends a message to the log, and notes the message's serial number *)
    fun append_message log message term serial = 
        let val new_entry = {
            term = term,
            command = message,
            serial = serial
        }
        in {
            log with
            lastMessageSerial = serial, 
            log = new_entry :: log.log
        } 
    end


    (* Appends a list of message to the log *)
    fun add_entries_to_log log entries term =
        case entries of
        [] => log
        | h :: t => 
            add_entries_to_log (append_message log h.command term h.serial) t
            h.term

    fun update_applied_inner log = {
        log with
        lastApplied = log.lastApplied + 1,
        internalChanges = log.internalChanges - 1
    }

    (* Updates the lastApplied-index*)
    fun update_applied log = {
        log with
        lastApplied = log.lastApplied + 1
    }
    
    (* Commits a message in the log *)
    fun update_commit log new_index = {
       log with 
       commitIndex = (max new_index log.commitIndex)
    }

    (* Rolls the log back one entry*)
    fun rollback_log log =
        let val (_ :: prev_log) = log.log
    in {
        log with 
        log = prev_log
    }
    end
    
    (* Get the entry of the latest log entry *)
    fun get_log_index log = (length log.log) + log.snapshot.lastIncludedIndex

    (* Rolls the log back n time *)
    fun rollback_log_to log n = 
        if n < (get_log_index log) then
            let val log = rollback_log log
            in (rollback_log_to log n)
        end
        else log

    (* Get the term of the latest entry of the log, or, if empty, the last
    included index of the snapshot*)
    fun get_latest_entry_term log =
        case log.log of
        [] => log.snapshot.lastIncludedTerm
        | h :: _ => h.term

    fun get_latest_log_term log = get_latest_entry_term log

    fun get_latest_log_command log = 
        case log.log of
        [] => 0 (* Should not be reachable*)
        | h :: _ => h.command

    fun get_nth_command log index = nth (reverse log.log) (index - log.snapshot.lastIncludedIndex) 

    (* Returns a slice of all entries after log-index n *)
    fun get_commands_after_nth log n =
        let val log_slice = slice (n - log.snapshot.lastIncludedIndex) (length log.log) (reverse log.log)
        in log_slice
        end

    (* Returns a slice of all entries after the commit-index *)
    fun uncommitted_entries log = get_commands_after_nth log log.commitIndex

    (* Applies all log-entries that have been committed, but not applied *)
    fun apply_log log f = 
        let fun apply_internal log = let 
                val lastApplied = min (log.lastApplied + log.internalChanges) log.commitIndex
                val internalChanges = log.internalChanges - (lastApplied - log.lastApplied)
            in { log with lastApplied = lastApplied,
                        internalChanges = internalChanges} end

            fun apply_external log f = if log.lastApplied < log.commitIndex 
                    then 
                        let val _ = f ((get_nth_command log (log.lastApplied + 1)).command) 
                        val log = update_applied log
                        in apply_external log f end
                    else log

            val new_log = apply_external (apply_internal log) f
        in new_log
    end

    fun update_state state trans_func log =
        if log.lastApplied < log.commitIndex then
            let val command = (get_nth_command log (log.lastApplied + 1)).command
                val state = trans_func (state, command)
                val log = update_applied log
            in update_state state trans_func log end
        else (state, log)
    
    (* Receive a snapshot of the state-machine's current state *)
    fun take_snapshot state_machine_pid hooks index term = 
        let val pid = self()
            val state = 
                send (state_machine_pid, (hooks.get_state_hook pid)); 
                receive[hn ("SNAPSHOT", x) => x]
        in set_snapshot state index term
    end

    (* Get a snapshot of all committed entries *)
    fun get_snapshot state_machine_pid hooks log = 
        if log.commitIndex > 0 andalso 
        (log.commitIndex - log.snapshot.lastIncludedIndex) <= length log.log then
            let val lastCommitted = get_nth_command log log.commitIndex
                val snapshot = take_snapshot state_machine_pid hooks log.commitIndex lastCommitted.term
            in snapshot end
        else empty_snapshot
        

    (* Applies a snapshot to the log *)
    fun apply_snapshot state_machine_pid snapshot log =
        let val uncommitted_entries = uncommitted_entries log
            val newCommitIndex =
                if log.commitIndex < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.commitIndex
            val newLastApplied =
                if log.lastApplied < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.lastApplied
        in { log with 
                log = uncommitted_entries,
                commitIndex = newCommitIndex,
                lastApplied = newLastApplied,
                snapshot = snapshot }
    end

    (* Generates a summary of the log containing the amount of committed
    entries, and the number of entries since the last Snapshot *)
    fun generate_summary log = 
        {applied_log_size = log.lastApplied, 
            entries_since_snap = (log.lastApplied - log.snapshot.lastIncludedIndex)}

    (* Asks the state-machine whether or not to snapshot *)
    fun evaluate_snapshot_cond state_machine_pid hooks log = 
        let val p_id = self ()
            val summary = generate_summary log
        in 
            send(state_machine_pid, (hooks.snapshot_condition_hook (summary, p_id)));
            receive [
                hn ("SNAPSHOT_CALLBACK", callback) => 
                    if callback then apply_snapshot state_machine_pid (get_snapshot state_machine_pid hooks log) log
                    else log
            ]
    end

    fun apply_state_changes state_machine_pid hooks log prev_state =
        if log.lastApplied < log.commitIndex then 
                let val applied_log = apply_log log (fn x => send (state_machine_pid, x))
                val p_id = self()
                val new_state =
                    send(state_machine_pid, hooks.get_state_hook p_id);
                    receive [
                        hn ("STATE_CALLBACK", state) => state
                    ]
            in (applied_log, new_state) end
        else (log, prev_state)

    
    fun prepend_internal_change changes node_term log = 
        let val insert_index = log.internalChanges + log.commitIndex - log.snapshot.lastIncludedIndex
            val term = if insert_index < (length log.log) then (get_nth_command log insert_index).term else node_term
            val change_entries = map (fn change => { term = term, command = change, serial = 0}) changes
            val entries = append_at_index (reverse log.log) change_entries insert_index 
        in { log with log = reverse entries,
                internalChanges = log.internalChanges + (length changes)}
    end

    fun add_internal_changes state_machine_pid hooks node_term log =
        let val p_id = self ()
            val changes =
                send(state_machine_pid, hooks.get_changes_hook p_id);
                receive [
                    hn ("CHANGES_CALLBACK", callback) => callback
                ]
        in 
            case changes of
            [] => log
            | h :: t => prepend_internal_change (h :: t) node_term log
            | _ => printString "ERROR: Changes should be a list of messages"; log
    end
        

    (* EXPORT END *)