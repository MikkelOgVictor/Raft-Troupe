import lists
(*
    LeaderInfo = {
        nextIndex = {
            peer: p,
            next: int
        }[],
        matchIndex = {
            peer: p,
            match: int
        }[]
    }
*)


let 

    fun filter f l = case l of
    [] => []
    | h :: t => if f h then h :: (filter f t) else filter f t

    fun first l = case l of
    [] => []
    | h :: _ => h


    fun new_leader all_nodes = let 
        val index = map (fn id => {peer = id, next = 0}) all_nodes
        val match_index = map (fn id => {peer = id, match = 0}) all_nodes
    in {
        nextIndex = index,
        matchIndex = match_index
    } end
    
    fun get_next_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.nextIndex)

    fun get_match_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.matchIndex)

    fun update_next_index leader_info peer new = let
        val prevIndex = get_next_index leader_info peer
        val newIndex = {peer = peer, next = new}
        val witoutPeer = filter (fn (x) => x.peer <> peer) leader_info.nextIndex
    in {
        leader_info with 
        nextIndex = newIndex :: witoutPeer
    } end

    fun update_match_index leader_info peer new = let
        val prevIndex = get_match_index leader_info peer
        val newIndex = {peer = peer, next = new}
        val witoutPeer = filter (fn (x) => x.peer <> peer) leader_info.matchIndex
    in {
        leader_info with 
        matchIndex = newIndex :: witoutPeer
    } end


in print (update_next_index (new_leader ["Kenobi", "Anakin"]) "Kenobi" 1)
end

