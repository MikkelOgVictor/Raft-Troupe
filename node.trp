import lists
let 
    fun node other_nodes id leader loops = 
        let fun send_to_all processes msg = 
            let fun send_and_loop h t =
                    let val _ = send(h, msg)
                    in send_to_all t msg
                    end
                in case processes of
                    [] => ()
                    | h :: t => send_and_loop h t
                end
            fun timeout cb = 
                let val time = 1000 + ((random ()) * 100)
                    val _ = sleep time
                    val seconds = time / 1000
            in send(cb, ("TIMEOUT", loops))
            end
            fun heartbeat_all () = send_to_all other_nodes ("HEARTBEAT", id)
            val pr_id = self()
            val _ = spawn (fn() => timeout pr_id)
        in receive [hn ("ADD_NODE", x) => node (append other_nodes [x]) id leader (loops + 1),
                    hn ("ADD_NODES", x) => node (append other_nodes x) id leader (loops + 1),
                    hn ("SEND_HEARTBEAT") => 
                        let val _ = printString (id ^ ":sending heartbeat")
                            val _ = spawn heartbeat_all
                        in node other_nodes id leader (loops + 1)
                        end,
                    hn ("HEARTBEAT", x) => 
                        let val _ = printString (id ^ ":received heartbeat from '"^x^"'")
                        in node other_nodes id leader (loops + 1)
                        end,
                    hn ("TIMEOUT", x) =>
                        if x = loops then
                            printString (id^": START ELECTION")
                        else node other_nodes id leader loops]
        end
    val node1 = spawn (fn() => node [] "1" false 0)
in send(node1, ("ADD_NODE", spawn (fn() => node [node1] "2" false 0)))
end