import lists
import quickselect

(*
    Log = {
        snapshot: Snapshot
        log: Entry[],
        lastApplied: int,
        commitIndex: int,
    }
    Snapshot = {
        snapshot: Some state
        lastIncludedIndex: int,
        lastIncludedTerm: int
    }
    Entry = {
        term: int,
        command: message
    }
*)

(*
    LeaderInfo = {
        nextIndex = {
            peer: p,
            next: int
        }[],
        matchIndex = {
            peer: p,
            match: int
        }[]
    }
*)

(*
    StateMachine = {
        set_hook: string,
        get_hook: string,
        snapshothook: fn a, b => ... return true they should be merged, false otherwise
    }
    LogManifest = {
        log_size: int,
        entries_since_snap: int
    }

*)

(*
    Node = {
        all_nodes: string[],
        id: string,
        log: Log,
        term: int,
        voted_for: string,
        leader: string,
        leader_info: LeaderInfo,
        state_machine: StateMachine,
        verbose: boolean
    }
*)


let fun not a = a = false
    fun send_to_all processes msg sender = map (fn x => send(x, msg)) (filter (fn x => x <> sender) processes)

    fun send_to_nth processes msg n = send((nth (reverse processes) n), msg)

    (*
        LOG FUNCTIONS BEGIN
    *)

    fun max a b = if a < b then b else a 

    fun min a b = if a > b then b else a

    fun set_snapshot snapshot index term =
    {
        snapshot = snapshot,
        lastIncludedIndex = index,
        lastIncludedTerm = term
    }

    fun take_snapshot state_machine index term = 
        let val pid = self()
            val _ = send (state_machine.pid, (state_machine.snapshot_gethook pid))
            val state = receive[hn ("SNAPSHOT", x) => x]
        in set_snapshot state index term
    end

    val empty_snapshot = set_snapshot () 0 0

    val empty_log = {
        log = [],
        snapshot = empty_snapshot,
        lastApplied = 0,
        commitIndex = 0
    }

    fun empty_log_with_snap snapshot = {
        log = [],
        snapshot = snapshot,
        lastApplied = 0,
        commitIndex = 0
    }

    fun append_message log message term = 
        let val new_entry = {
            term = term,
            command = message
        }
        in {
            log with 
            log = new_entry :: log.log
        } 
    end

    fun add_entries_to_log log entries term =
        case entries of
        [] => log
        | h :: t => add_entries_to_log (append_message log h.command term) t h.term

    fun update_applied log = {
        log with
        lastApplied = log.lastApplied + 1
    }
    
    fun update_commit log new_index = {
       log with 
       commitIndex = (max new_index log.commitIndex)
    }

    fun rollback_log log =
        let val (_ :: prev_log) = log.log
    in {
        log with 
        log = prev_log
    }
    end

    fun get_log_index log = (length log.log) + log.snapshot.lastIncludedIndex

    fun rollback_log_to log n = 
        if n < (get_log_index log) then
            let val log = rollback_log log
            in (rollback_log_to log n)
        end
        else log

    fun get_latest_entry_term log =
        case log.log of
        [] => log.snapshot.lastIncludedTerm
        | h :: _ => h.term

    fun get_latest_log_term log = get_latest_entry_term log

    fun get_latest_log_command log = 
        case log.log of
        [] => 0 (* Should not be reachable*)
        | h :: _ => h.command

    fun get_nth_command log index = nth (reverse log.log) (index - log.snapshot.lastIncludedIndex) 

    fun get_commands_after_nth log n =
        let val log_slice = slice (n - log.snapshot.lastIncludedIndex) (length log.log) (reverse log.log)
        in log_slice
        end

    fun uncommitted_entries log = slice (get_log_index log) log.commitIndex log.log

    fun apply_log log f = if log.lastApplied < log.commitIndex 
        then 
            let val _ = f ((get_nth_command log (log.lastApplied + 1)).command) 
            val log = update_applied log
            in apply_log log f end
        else log
    
    fun get_snapshot state_machine log = 
        let val lastCommitted = get_nth_command log log.commitIndex
        in take_snapshot state_machine log.commitIndex lastCommitted.term
    end

    fun apply_snapshot state_machine snapshot log =
        let val _ = send(state_machine.pid, snapshot.snapshot)
            val uncommitted_entries = uncommitted_entries log
            val newCommitIndex = 
                if log.commitIndex < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.commitIndex
            val newLastApplied =
                if log.lastApplied < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.lastApplied
            val log = {log with log = uncommitted_entries}
            val log = {log with commitIndex = newCommitIndex}
            val log = {log with lastApplied = newLastApplied}
        in { log with snapshot = snapshot }
    end
    (* LOG FUNCTIONS END *)



    (* LEADERINFO FUNCTIONS BEGIN*)

    fun new_leader all_nodes log = 
        let val nextIndex = get_log_index log
            val index = map (fn id => {peer = id, next = nextIndex + 1}) all_nodes
            val match_index = map (fn id => {peer = id, match = 0}) all_nodes
        in {
            nextIndex = index,
            matchIndex = match_index
        } end
    
    fun get_next_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.nextIndex)

    fun get_match_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.matchIndex)

    fun update_next_index leader_info peer new = let
        val prevIndex = get_next_index leader_info peer
        val newIndex = {peer = peer, next = new}
        val witoutPeer = filter (fn (x) => x.peer <> peer) leader_info.nextIndex
    in {
        leader_info with 
        nextIndex = newIndex :: witoutPeer
    } end

    fun update_match_index leader_info peer new = let
        val prevIndex = get_match_index leader_info peer
        val newIndex = {peer = peer, match = new}
        val witoutPeer = filter (fn (x) => x.peer <> peer) leader_info.matchIndex
    in {
        leader_info with 
        matchIndex = newIndex :: witoutPeer
    } end


    fun get_matches leader_info = map (fn x => x.match) leader_info.matchIndex

    fun calc_highest_commit matches = median matches

    (* LEADERINFO FUNCTIONS END*)

    (* KEY VALUE FUNCTIONS BEGIN *)

    fun key_val_store () = 
        let fun remove element list = 
            case list of 
            [] => []
            | h :: t => 
                if h = element then t
                else append [h] (remove element t)
        fun get_record key dic =
            case dic of
                [] => ()
                | h :: t => 
                    if h.key = key then h
                    else get_record key t
        fun get key dic = 
            let val record = get_record key dic
            in if record = () then ()
                else record.value
            end
        fun set (key, value) dic = 
            let val existing_record = get_record key dic 
                val new_record = {key = key, value = value}
            in if existing_record = () then 
                append [{key = key, value = value}] dic
            else 
                if new_record = existing_record then dic
                else append [new_record] (remove existing_record dic)
            end
        fun drop key dic = 
            remove (get_record key dic) dic
        val dic = []
        fun loop dic = 
            let val dic = receive [
                hn ("SET", (key, value)) => set (key, value) dic,
                hn ("GET", (key, sender_id)) => 
                    let val _ = send(sender_id, ("RESPONSE", (get key dic)))
                    in dic
                    end,
                hn ("GET_SNAPSHOT", sender_id) => 
                    let val _ = send(sender_id, ("SNAPSHOT", dic))
                    in dic
                    end,
                hn ("SET_SNAPSHOT", other_dic) => loop other_dic,
                hn ("SNAPSHOT?", (log_manifest, sender_id)) => 
                    let val callback = log_manifest.log_size > (length dic) 
                        andalso log_manifest.entries_since_snap > 50
                    in send(sender_id, ("CALLBACK", callback)) end,
                hn ("DROP", key) => drop key dic
            ]
            in loop dic
            end
        in loop dic
    end
    (* KEY VALUE FUNCTIONS END*)

    fun verbose_print x verbose = if verbose then print x else ()

    fun start_timeout func duration = 
        let fun timeout () = 
            let val time = duration
                val _ = sleep time
            in func ()
            end
            val p_id = self()
        in spawn timeout
    end

    fun start_random_timeout func = start_timeout func (1000 + ((random ()) * 1000))
    
    fun leader_node node = 
        let val p_id = self()
            fun append_entries follower_pid =
                    let val nextIndex = get_next_index node.leader_info follower_pid
                    val logIndex = get_log_index node.log
                in if logIndex + 1 >= nextIndex.next then 
                    let 
                        val latestLogIndex = nextIndex.next - 1
                    in 
                        if nextIndex.next <= node.log.snapshot.lastIncludedIndex 
                            then send(follower_pid, ("Snapshot", node.log.snapshot, p_id, node.term))
                        else 
                            let 
                                val entries = get_commands_after_nth node.log latestLogIndex
                                val afterSnapshot = latestLogIndex - node.log.snapshot.lastIncludedIndex
                                val prevEntryTerm = 
                                    if afterSnapshot > 0 then (get_nth_command node.log latestLogIndex).term 
                                    else node.log.snapshot.lastIncludedTerm
                            in send(follower_pid, ("AppendEntries", entries, p_id, node.term, latestLogIndex, prevEntryTerm, node.log.commitIndex))
                        end
                end
                else print "ERROR"
            end

            fun demote term leader voted_for node = 
                let val node = { node with term = term }
                    val node = { node with leader = leader}
                    val node = { node with leader_info = ()}
                in {node with voted_for = voted_for}
            end

            fun apply_committed node = 
                let val highest_commit = calc_highest_commit (map (fn x => x.match) node.leader_info.matchIndex)
                    val node = { node with log = update_commit node.log highest_commit }
                in { node with log = apply_log node.log (fn x => send (node.state_machine.pid, x)) }
                end

            val _ = map (fn x => append_entries x) (filter (fn x => x <> p_id) node.all_nodes)
            val nonce = mkuuid ()
            val _ = start_timeout (fn () => send (p_id, ("SEND_HEARTBEAT", nonce))) 500
            fun loop node = 
                let val node = apply_committed node
                val _ = receive [
                    hn ("SEND_HEARTBEAT", x) when nonce = x =>
                        let val _ = verbose_print (node.id^": Sending heartbeat") node.verbose
                        in leader_node node end,
                    
                    hn (("RAFT-UPDATE", x), dialer_id) => 
                        let val latestLogIndex = get_log_index node.log
                            val prevLogTerm = get_latest_log_term node.log
                            val node = {node with log = append_message node.log (node.state_machine.sethook x) node.term}
                            val node = { node with leader_info = update_match_index node.leader_info p_id (get_log_index node.log)}
                            val node = { node with leader_info = update_next_index node.leader_info p_id ((get_log_index node.log) + 1) }
                            val _ = verbose_print (node.id^": Appending new message to log") node.verbose
                        in leader_node node end,

                    hn (("RAFT-GET", x), dialer_id) =>
                        let val _ = send (node.state_machine.pid, (node.state_machine.gethook x))
                        in loop node end,

                    hn ("ACKNOWLEGDE", (peer, logIndex)) => (*Dette er hvis append er en success*)
                        let val node = { node with leader_info = update_match_index node.leader_info peer logIndex }
                            val node = { node with leader_info = update_next_index node.leader_info peer (logIndex + 1) }
                        in loop node end,
                    
                    hn ("REJECT", (peer, terminfo, logIndex)) => 
                        if node.term >= terminfo.term then 
                            let val node = { node with leader_info = update_next_index node.leader_info peer (logIndex + 1) } 
                            in loop node 
                            end
                        else follower (demote terminfo.term terminfo.leader () node),
                    hn ("SEND_HEARTBEAT", x) when nonce = x =>
                        let val _ = verbose_print (node.id^": Sending heartbeat") node.verbose
                        in leader_node node end,
                    
                    hn ("RAFT-UPDATE", x) => 
                        let val latestLogIndex = get_log_index node.log
                            val prevLogTerm = get_latest_log_term node.log
                            val node = {node with log = append_message node.log (node.state_machine.sethook x) node.term}
                            val node = { node with leader_info = update_match_index node.leader_info p_id (get_log_index node.log)}
                            val node = { node with leader_info = update_next_index node.leader_info p_id ((get_log_index node.log) + 1) }
                            val _ = verbose_print (node.id^": Appending new message to log") node.verbose
                        in loop node end,

                    hn ("RAFT-GET", x) =>
                        let val _ = send (node.state_machine.pid, (node.state_machine.gethook x))
                        in loop node end,

                    hn ("RequestVote", (c_term, other_c_id, c_log_index, c_log_term, p_id)) when c_term > node.term =>
                        let val _ = send(p_id, ("YES-VOTE", node.id))
                        in follower (demote c_term () other_c_id node)
                        end,

                    hn ("Snapshot", snapshot, l_id, other_term) when other_term > node.term =>
                        let val _ = verbose_print (node.id^": received Snapshot from leader, I must have lost position") node.verbose
                        in follower (demote other_term l_id () node)
                        end,

                    hn ("AppendEntries", x, l_id, other_term, prevIndex, prevTerm, commitIndex) when other_term > node.term => 
                        let val _ = verbose_print (node.id^": received AppendEntries from leader, I must have lost position") node.verbose
                        in follower (demote other_term l_id () node)
                        end,
                        
                    hn ("debug-printlog") =>
                        let val _ = print node.id
                            val _ = print node.log
                        val _ = print node.leader_info
                        in loop node end,
                    hn ("debug-pause") =>
                        let fun pause () = receive [
                            hn ("debug-continue") => loop node,
                            hn x => pause ()
                        ]
                        in pause () end,
                    hn ("debug-applysnapshot") =>
                        let val snapshot = get_snapshot node.state_machine node.log
                            val node = {node with log = apply_snapshot node.state_machine snapshot node.log}
                            val _ = verbose_print (node.id^": applying snapshot") node.verbose
                        in loop node end,
                        hn ("print-entries") =>
                        let val _ = print node.id
                            val _ = print node.log.entries
                            val _ = print node.log.snapshot.snapshot
                        in loop node end,
                    hn _ => loop node
                ] 
                in ()  (* Vi skal sørge for at genstarte løkken i receive ellers opdatere loggen ikke*)
            end
        in loop node
    end

    and candidate node =
        let val p_id = self()
            val node = {node with voted_for = (), leader = ()}
            val nonce = mkuuid()
            val _ = verbose_print (node.id^": I am now a candidate") node.verbose
            val latestLogIndex = get_log_index node.log
            val prevLogTerm = get_latest_log_term node.log
            val _ = send_to_all node.all_nodes ("RequestVote", (node.term, node.id, latestLogIndex, prevLogTerm, p_id)) (p_id)
            val req_votes = ((length node.all_nodes) / 2)
            fun won_election () = 
                let val _ = verbose_print (node.id^": I won the election") node.verbose
                in leader_node { node with leader_info = (new_leader node.all_nodes node.log) }
            end
            
            fun wait_for_votes (follower_votes, vote_amount) = 
                let 
                    fun loop () = receive [
                    hn ("JOIN_CLUSTER", p_id) => send(p_id, ("NOT_LEADER", ())),
                    hn ("YES-VOTE", follower_id) when (not (contains follower_id follower_votes)) => 
                        wait_for_votes ((append follower_votes [follower_id]), vote_amount + 1),

                    hn ("NO-VOTE", other_term) when other_term > node.term =>
                        follower node,

                    hn ("RequestVote", (c_term, other_c_id, c_log_index, c_log_term, p_id)) when c_term > node.term =>
                        let val _ = send(p_id, ("YES-VOTE", node.id))
                        in follower ({ node with term = c_term, voted_for = other_c_id})
                        end,
                    
                    hn ("AppendEntries", x, l_id, other_term, prevIndex, prevTerm, commitIndex) when other_term >= node.term => 
                        let val _ = verbose_print (node.id^": received AppendEntries from leader, I must have lost position") node.verbose
                        in follower ({ node with leader = l_id})
                        end,

                    hn ("VOTE-TIMEOUT", x) when x = nonce => candidate {node with term = node.term + 1},

                    hn ("debug-pause") =>
                        let fun loop () = receive [
                            hn ("debug-continue") => (),
                            hn x => loop ()
                        ]
                        in loop () end,
                    hn _ => loop ()
                ]
                in if vote_amount >= req_votes then won_election () else loop ()
            end
            val _ = start_random_timeout (fn () => send(p_id, ("VOTE-TIMEOUT", nonce)))
        in wait_for_votes ([node.id], 1) 
    end
    
    and follower node = 
        let val p_id = self()
            val nonce = mkuuid()
            val _ = start_random_timeout (fn () => send(p_id, ("ELECTION-TIMEOUT", nonce)))
            fun vote_for c_id c_term node = 
                let val node = {node with voted_for = c_id}
                in {node with term = c_term} 
            end
            fun loop node = 
                let val node = { node with log = apply_log node.log (fn x => send (node.state_machine.pid, x)) }
                fun start_election () =
                    let val _ = verbose_print (node.id^": START ELECTION") node.verbose
                    in candidate ({node with term = node.term + 1})
                    end
                val _ = receive [
                hn ("JOIN_CLUSTER", p_id) => send(p_id, ("NOT_LEADER", node.leader)),
                hn ("ADD_NODES", x) => 
                    follower ({node with all_nodes = append node.all_nodes x}),
                hn ("ELECTION-TIMEOUT", x) when x = nonce => start_election (),

                hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term, p_id)) when c_id = node.voted_for =>
                    let val _ = send(p_id, ("YES-VOTE", node.id))
                        val _ = verbose_print (node.id^": Voting yes") node.verbose
                        in follower (vote_for c_id c_term node)
                        end,
                
                hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term, p_id)) =>
                    let val latestLogIndex = get_log_index node.log
                        val latestLogTerm = get_latest_log_term node.log
                        fun no_vote () =
                            let val _ = send(p_id, "NO-VOTE")
                                val _ = verbose_print (node.id^":voting no") node.verbose
                            in follower node
                        end
                        fun yes_vote () =
                            let val _ = send(p_id, ("YES-VOTE", node.id))
                                val _ = verbose_print (node.id^": Voting yes") node.verbose
                            in follower (vote_for c_id c_term node)
                        end
                    in 
                        if latestLogIndex > c_log_index then no_vote ()
                        else if latestLogTerm > c_log_term then no_vote ()
                        else if c_term <= node.term then no_vote ()
                        else yes_vote ()
                    end,
                hn ("Snapshot", x, l_id, leader_term) =>
                    let val node = {node with leader = 
                            if node.leader = () orelse node.term < leader_term then l_id
                            else node.leader}
                        val {snapshot, lastIncludedIndex, lastIncludedTerm} = x
                        val log_term = get_latest_log_term node.log
                        val log_index = get_log_index node.log

                        val accepting = 
                            if leader_term < node.term then false
                            else if lastIncludedIndex <= log_index then false
                            else true

                        val newlog = if accepting then apply_snapshot node.state_machine x node.log else node.log
                        val reject = fn () => send (l_id, ("REJECT", (p_id, {term = term, leader = leader}, (get_log_index newlog))))
                        val ack = fn () => send (l_id, ("ACKNOWLEGDE", (p_id, get_log_index newlog)))

                        val newlog = if accepting then apply_snapshot node.state_machine x node.log else node.log
                        val reject = 
                            fn () => send (l_id, ("REJECT", (p_id, {term = node.term, leader = node.leader}, (get_log_index newlog))))
                        val ack = 
                            fn () => send (l_id, ("ACKNOWLEGDE", (p_id, get_log_index newlog)))

                        val node = {node with term = (if node.term < leader_term then leader_term else node.term)}
                        
                        val _ = if accepting then ack ()
                                else reject ()
                    in follower {node with log = newlog}
                    end,
                hn ("AppendEntries", x, l_id, leader_term, latestLogIndex, prevLogTerm, leaderCommit) => 
                    let val node = {node with leader = 
                            if node.leader = () orelse node.term < leader_term then l_id
                            else node.leader}
                        val accepting = 
                            if leader_term < node.term then false
                            else if latestLogIndex > (get_log_index node.log) then false
                            else if (get_latest_log_term node.log) <> prevLogTerm then false
                            else true
                        val newlog = 
                            if accepting then
                                let val log = rollback_log_to node.log latestLogIndex
                                    val log = add_entries_to_log log x leader_term
                                in update_commit log (min leaderCommit (get_log_index log)) 
                                end
                            else node.log
                        val reject = 
                            fn () => send (l_id, ("REJECT", (p_id, {term = node.term, leader = node.leader}, (get_log_index newlog))))
                        val ack = 
                            fn () => send (l_id, ("ACKNOWLEGDE", (p_id, get_log_index newlog)))

                        val node = {node with term = (if node.term < leader_term then leader_term else node.term)}
                        val _ = if accepting then ack ()
                                else 
                                    let val _ = verbose_print (node.id^": REJECTING") node.verbose
                                    in reject ()
                                    end
                    in follower {node with log = newlog}
                    end,

                hn (("RAFT-UPDATE", x), dialer_id) => 
                    send(dialer_id, ("UPDATE-NOT-LEADER", node.leader, x)),
                
                hn (("RAFT-GET", x), dialer_id) => 
                    send(dialer_id, ("GET-NOT-LEADER", node.leader, x)),

                hn ("debug-printlog") =>
                    let val _ = print node.id
                    in print node.log end,

                hn ("print-entries") =>
                    let val _ = print node.id
                        val _ = print node.log.entries
                    in print node.log.snapshot.snapshot end,

                hn ("debug-pause") =>
                    let fun loop () = receive [
                        hn ("debug-continue") => (),
                        hn x => loop ()
                    ]
                    in loop () end,
                hn ("debug-timeout") => start_election (),
                hn _ => loop node
            ]
            in loop node
        end
        in loop node
    end
    
    fun default_node all_nodes id state_machine_record verbose = 
        let val node = {
            all_nodes = all_nodes,
            id = id,
            log = empty_log,
            term = 1,
            voted_for = (),
            leader = (),
            leader_info = (),
            state_machine = state_machine_record,
            verbose = verbose
        }
        in fn() => follower node
    end

    fun initiate_node all_nodes id state_machine sethook gethook snapshot_gethook snapshot_sethook verbose = 
        let val state_machine_pid = spawn state_machine 
            val state_machine_record = 
                {pid = state_machine_pid, 
                sethook = sethook, 
                gethook = gethook, 
                snapshot_gethook = snapshot_gethook,
                snapshot_sethook = snapshot_sethook}
        in spawn (default_node all_nodes id state_machine_record verbose)
    end
    fun initiate_distributed_node all_nodes id alias state_machine = 
        let val state_machine_pid = spawn(alias, state_machine)
        in spawn(alias, (default_node all_nodes id state_machine_pid))
    end
    
    fun initiate_nodes n state_machine sethook gethook snapshot_gethook snapshot_sethook verbose =
        let fun get_nodes n acc_id =
                case n of
                0 => []
                | x => append 
                    (get_nodes (x - 1) (acc_id ^ "I")) 
                    [(initiate_node [] acc_id state_machine sethook gethook snapshot_gethook snapshot_sethook verbose)]
            
            fun add_refs nodes = 
                let fun loop remaining = 
                    case remaining of
                    [] => ()
                    | h :: t => 
                        let val _ = send(h, ("ADD_NODES", nodes))
                        in loop t
                        end
                in loop nodes
                end
            val nodes = get_nodes n "I"
            val _ = add_refs nodes
        in nodes
    end

    fun dialer cluster = 
        let val p_id = self()
            val leader = nth cluster 1
            fun loop leader =     
                let val leader = receive [
                    hn ("RAFT-UPDATE", x) =>
                        send(leader, (("RAFT-UPDATE", x), p_id));
                        leader,

                    hn ("RAFT-GET", x) =>
                        send(leader, (("RAFT-GET", x), p_id));
                        leader,

                    hn ("UPDATE-NOT-LEADER", leader_id, x) => 
                        let val leader = 
                            if leader_id = () then 
                                sleep 20;
                                leader
                            else leader_id
                        in 
                            send(leader, (("RAFT-UPDATE", x), p_id));
                            leader
                        end,

                    hn ("GET-NOT-LEADER", leader_id, x) => 
                        let val leader = 
                            if leader_id = () then 
                                sleep 20;
                                leader
                            else leader_id
                        in 
                            send(leader, (("RAFT-GET", x), p_id));
                            leader
                        end,

                    hn ("SEND-TO-NTH", n, x) =>
                        send_to_nth cluster x n;
                        leader,

                    hn ("SEND-TO-ALL", x) => 
                        send_to_all cluster ("debug-printlog") (self());
                        leader,
                    hn x =>
                        send(leader, x); print x;
                        leader ]
                in loop leader end
        in loop leader
    end

    fun raft state_machine_func set_hook get_hook get_snapshot_hook set_snapshot_hook verbose =
        let val nodes = initiate_nodes 5 state_machine_func set_hook get_hook get_snapshot_hook set_snapshot_hook verbose
            val dialer = (fn () => dialer nodes)
        in spawn dialer
    end

    fun key_val_store_init verbose =
        raft key_val_store 
            (fn x => case x of (key, value) => ("SET", (key, value))) 
            (fn (x, callback_pid) => ("GET", (x, callback_pid)))
            (fn (callback_pid) => ("GET_SNAPSHOT", callback_pid))
            (fn x => ("SET_SNAPSHOT", x))
            (fn (log_manifest, callback_pid) => ("SNAPSHOT?", (log_manifest, callback_pid)))
            verbose

    fun send_delay (to, m) delay =
        sleep delay;
        send (to, m)

    fun send_n_updates raft n =
        let fun loop n =
            let val _ = send(raft, ("RAFT-UPDATE", ("TEST", "TEST")));
                        print n;
                        sleep 10
            in if n > 1 then loop (n - 1) else () end 
        in loop n 
    end

    fun test_local1 n = 
        let val raft = key_val_store_init true
        in
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 500;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-pause")) 1000;
            print "killing I";
            send(raft, ("RAFT-UPDATE", ("Hello", "World"))) 2000;
            print "reviving I";
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-continue")) 2000;
            send(raft, ("SEND-TO-NTH", 1, ("RAFT-UPDATE", ("Hello", "Other World"))));
            send_delay(raft, ("SEND-TO-ALL", "debug-log")) 2000
    end

    fun test2_local () = 
        let val raft = key_val_store_init true
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send(raft, ("SEND-TO-NTH", 2, "debug-timeout"));
            send_delay(raft, ("SEND-TO-ALL", "debug-log")) 1000
    end

    fun test3_local () = 
        let val p_id = self()
            val raft = key_val_store_init true
        in 
            send_delay(raft, ("RAFT-UPDATE", ("A", 42))) 2000;
            send_delay(raft, ("RAFT-GET", ("A", p_id))) 1000;
            receive [hn x => print x]
    end

    fun test4_local () = 
        let val raft = key_val_store_init true
        in
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send(raft, ("RAFT-UPDATE", ("Hello", "There")));
            send_delay(raft, ("SEND-TO-ALL", "debug-log")) 5000
    end

    fun test_snapshot () =
        let val raft = key_val_store_init true
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_delay(raft, ("SEND-TO-NTH", 3, "debug-pause")) 100;
            send(raft, ("RAFT-UPDATE", ("A", 1)));
            send_delay(raft, ("RAFT-UPDATE", ("A", 2))) 50;
            send_delay(raft, ("RAFT-UPDATE", ("A", 4))) 50;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-applysnapshot")) 100;
            send_delay(raft, ("SEND-TO-NTH", 3, "debug-continue")) 100;
            send_delay(raft, ("SEND-TO-ALL", "debug-log")) 500
    end

    fun test_lots_of_messages () = 
        let val raft = key_val_store_init true 
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            sleep 2000;
            send_n_updates raft 1000;
            send(raft, ("SEND-TO-NTH", 1, "debug-applysnapshot"));
            sleep 5000;
            send_n_updates raft 1000;
            send_delay(raft, ("SEND-TO-ALL", "debug-log")) 1000

    end
    
    (*fun initiate_3_distributed_nodes () =
        let 
            val node1 = initiate_distributed_node [] "1" "@node1" key_val_store
            val node2 = initiate_distributed_node [node1] "2" "@node2" key_val_store
            val node3 = initiate_distributed_node [node2, node1] "3" "@node3" key_val_store
            val all_nodes = [node1, node2, node3]
            val _ = send(node1, ("ADD_NODES", [node2, node3]))
            val _ = send(node2, ("ADD_NODES", [node3]))
            val _ = sleep 2000
            val _ = send_to_all all_nodes ("RAFT-UPDATE", ("Victor", "Gruppemedlem 1")) (self())
            val _ = sleep 2000
            val _ = send_to_all all_nodes ("RAFT-UPDATE", ("Victor", "Gruppemedlem 2")) (self())
            val _ = sleep 2000
            val _ = send_to_all all_nodes ("debug-printlog") (self())
        in receive [hn x => print x]
    end*)
        
in test_lots_of_messages ()
end
