import lists
let 
    fun list_length list = 
        case list of
        [] => 0
        | _ :: t => 1 + list_length t

    fun send_to_all processes msg sender = 
        let fun send_and_loop h t =
            let val _ = send(h, msg)
            in send_to_all t msg sender
            end
        in case processes of
            [] => ()
            | h :: t =>
                if h = sender then send_to_all t msg sender
                else send_and_loop h t
        end

    fun start_timeout func = 
        let fun timeout () = 
            let val time = 1000 + ((random ()) * 100)
                val _ = sleep time
            in func ()
            end
            val p_id = self()
        in spawn timeout
        end

    fun leader_node all_nodes id loops log term = 
        let fun loop () = leader_node all_nodes id loops log term
            fun heartbeat_all () = send_to_all all_nodes ("HEARTBEAT", id) (self())
            val _ = heartbeat_all ()
            val _ = sleep 500
        in loop ()
        end

    and await_election_end all_nodes id loops log term = 
    let val _ = printString (id^": now waiting for election to end")
    in receive [hn ("HEARTBEAT", x) => 
        let val _ = printString (id ^ ":received heartbeat from '"^x^"', election must be over")
        in new_follower all_nodes id (loops + 1) log term
    end]
    end

    and candidate all_nodes id loops log term =
        let val p_id = self()
            val _ = printString (id^": I am now a candidate")
            val _ = send_to_all all_nodes ("ELECTME", (p_id, log, term)) (self())
            val req_votes = ((list_length all_nodes) / 2 + 1)
            fun won_election () = 
                let val _ = printString (id^": I won the election")
                in leader_node all_nodes id loops log term
                end
            
            fun wait_for_votes acc_votes = 
                let val _ = if acc_votes >= req_votes then won_election () else ()
                in receive [
                    hn ("YES-VOTE", x) => 
                        if term = x then wait_for_votes (acc_votes + 1) 
                        else wait_for_votes acc_votes,
                    hn ("ELECTME", (p_id, other_log, other_term)) =>
                        if other_term > term then
                            let val _ = send(p_id, ("YES-VOTE", other_term))
                            in await_election_end all_nodes id log other_term
                            end
                        else wait_for_votes acc_votes,
                    hn ("HEARTBEAT", x) => 
                        let val _ = printString (id^": received heartbeat from leader, I must have lost election")
                        in new_follower all_nodes id loops log term
                        end,
                    hn ("VOTE-TIMEOUT") => new_candidate all_nodes id loops log term
                ]
                end
            val p_id = self()
            val _ = start_timeout (fn () => send(p_id, "VOTE-TIMEOUT"))
        in wait_for_votes 1 
        end
    and new_candidate all_nodes id loops log term = candidate all_nodes id loops log (term + 1)
    
    and follower all_nodes id loops startTimeout log term = 
        let fun loop new_timeout = 
            if new_timeout then follower all_nodes id (loops + 1) true log term
            else follower all_nodes id loops false log term
            
            val _ = if startTimeout then 
                    let val p_id = self()
                    in start_timeout (fn () => send(p_id, ("ELECTION-TIMEOUT", loops))) 
                    end 
                else ()
        in receive [
            hn ("ADD_NODES", x) => follower (append all_nodes x) id (loops + 1) true log term,
            hn ("HEARTBEAT", x) => 
                let val _ = printString (id ^ ":received heartbeat from '"^x^"'")
                in loop true
                end,
            hn ("ELECTION-TIMEOUT", x) =>
                if x = loops then 
                    let val _ = printString (id^": START ELECTION")
                    in new_candidate all_nodes id loops log term
                    end
                else loop false,
            hn ("ELECTME", (p_id, c_log, c_term)) =>
                if c_term > term then
                    let val _ = send(p_id, ("YES-VOTE", c_term))
                    in await_election_end all_nodes id loops log c_term
                    end
                else
                    let val _ = send(p_id, "NO-VOTE")
                        val _ = printString (id^":voting no")
                    in loop true
                    end,
            hn ("debug-ELECTME") =>
                leader_node all_nodes id log term,
            hn x => 
                let val _ = print x
                in loop false
                end]
        end
    and new_follower all_nodes id loops log term = follower all_nodes id loops true log term
    fun initiate_node all_nodes id = spawn (fn() => follower all_nodes id 0 true 0 1)
    fun initiate_nodes n =
        let fun get_nodes n acc_id =
                case n of
                0 => []
                | x => append (get_nodes (x - 1) (acc_id ^ "I")) [(initiate_node [] acc_id)]
            fun add_refs nodes = 
                let fun loop remaining = 
                    case remaining of
                    [] => ()
                    | h :: t => 
                        let val _ = send(h, ("ADD_NODES", nodes))
                        in loop t
                        end
                in loop nodes
                end
        in add_refs (get_nodes n "I")
        end
    fun initiate_3_test_nodes () =
        let val node1 = initiate_node [] "1"
            val node2 = initiate_node [node1] "2"
            val node3 = initiate_node [node1, node2] "3"
            val _ = send(node1, ("ADD_NODES", [node2, node3]))
            val _ = send(node2, ("ADD_NODES", [node3]))
            val _ = send(node1, ("ELECTION-TIMEOUT", 1))
        in send(node2, ("ELECTION-TIMEOUT", 1))
    end
in initiate_nodes 5
end