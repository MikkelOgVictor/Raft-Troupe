import lists
let 
    fun contains element list = 
        case list of
        [] => false
        | h :: t =>
            if h = element then true
            else contains element t

    fun not a = a = false

    fun send_to_all processes msg sender = 
        let fun send_and_loop h t =
            let val _ = send(h, msg)
            in send_to_all t msg sender
            end
        in case processes of
            [] => ()
            | h :: t =>
                if h = sender then send_to_all t msg sender
                else send_and_loop h t
    end

    fun start_timeout func = 
        let fun timeout () = 
            let val time = 1000 + ((random ()) * 100)
                val _ = sleep time
            in func ()
            end
            val p_id = self()
        in spawn timeout
    end

    fun leader_node all_nodes id log term = 
        let val p_id = self()
            fun heartbeat () = 
                let val _ = send_to_all all_nodes ("AppendEntries", "heartbeat", id) (p_id)
                    val _ = sleep 500
                in heartbeat ()
            end
            val _ = printString (id^": spawning heartbeat")
            val _ = spawn heartbeat
            fun loop log term = 
                let val _ = receive [
                    hn ("SEND-MESSAGE", x) =>
                        let val _ = print ("Sending message '"^x^"'...")
                        in send_to_all all_nodes ("AppendEntries", x, id) (p_id)
                        end]
                in loop log term
            end
        in loop log term
        end

    and candidate all_nodes id log term =
        let val p_id = self()
            val nonce = mkuuid()
            val _ = printString (id^": I am now a candidate")
            val _ = send_to_all all_nodes ("RequestVote", (term, id, 0, 0 (*two arguments left for logs*), p_id)) (self())
            val req_votes = ((length all_nodes) / 2 + 1)systemctl stasystemctl status rc-local.servicetus rc-local.service
            fun won_election () = 
                let val _ = printString (id^": I won the election")
                in leader_node all_nodes id log term
                end
            
            fun wait_for_votes (follower_votes, vote_amount) = 
                let fun loop () = receive [
                    hn ("YES-VOTE", follower_id) when (not (contains follower_id follower_votes)) => 
                        wait_for_votes ((append follower_votes [follower_id]), vote_amount + 1),
                    hn ("NO-VOTE", other_term) when other_term > term =>
                        follower all_nodes id log term (),
                    hn ("RequestVote", (c_term, other_c_id, c_log_index, c_log_term, p_id)) =>
                        if c_term > term then
                            let val _ = send(p_id, ("YES-VOTE", id))
                            in follower all_nodes id log term
                            end
                        else wait_for_votes (follower_votes, vote_amount),
                    
                    hn ("AppendEntries", x) => 
                        let val _ = printString (id^": received AppendEntries from leader, I must have lost election")
                        in follower all_nodes id log term ()
                        end,
                    hn ("VOTE-TIMEOUT", nonce) => candidate all_nodes id log (term + 1)
                ]
                in if vote_amount >= req_votes then won_election () else loop ()
            end
            val _ = start_timeout (fn () => send(p_id, ("VOTE-TIMEOUT")))
        in wait_for_votes ([id], 1) 
        end
    
    and follower all_nodes id log term voted_for leader = 
        let fun loop all_nodes log term voted_for leader = 
            let val nonce = mkuuid()
                val p_id = self()
                val _ = start_timeout (fn () => send(p_id, ("ELECTION-TIMEOUT", nonce)))
                val _ = receive [
                hn ("ADD_NODES", x) => 
                    loop (append all_nodes x) log term voted_for leader,
                hn ("ELECTION-TIMEOUT", x) when x = nonce =>
                    let val _ = printString (id^": START ELECTION")
                    in candidate all_nodes id log (term + 1) leader
                    end,
                hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term, p_id)) when voted_for = () =>
                    if c_term > term then
                        let val _ = send(p_id, ("YES-VOTE", id))
                            val _ = printString (id^": Voting yes")
                        in loop all_nodes log term c_id leader
                        end
                    else
                        let val _ = send(c_id, "NO-VOTE")
                            val _ = printString (id^":voting no")
                        in loop all_nodes log term () leader
                        end,
                hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term, p_id)) when c_id = voted_for =>
                    let val _ = send(p_id, ("YES-VOTE", id))
                        val _ = print "Voting yes"
                        in loop all_nodes log term c_id leader
                        end,
                hn ("AppendEntries", x, l_id) when l_id = leader => 
                    let val _ = printString (id ^ ": received message '"^x^"'")
                    in loop all_nodes log term () leader
                    end,
                hn ("AppendEntries", x, l_id) when leader = () => 
                    let val _ = printString (id ^ ": received message '"^x^"'")
                    in loop all_nodes log term () l_id
                    end,
                hn ("debug-RequestVote") =>
                    leader_node all_nodes id log term leader]
                in loop all_nodes id log term voted_for
                end
        in loop all_nodes log term voted_for leader
        end
    fun initiate_node all_nodes id = spawn (fn() => follower all_nodes id 0 1 () ())
    fun initiate_nodes n =
        let fun get_nodes n acc_id =
                case n of
                0 => []
                | x => append (get_nodes (x - 1) (acc_id ^ "I")) [(initiate_node [] acc_id)]
            fun add_refs nodes = 
                let fun loop remaining = 
                    case remaining of
                    [] => ()
                    | h :: t => 
                        let val _ = send(h, ("ADD_NODES", nodes))
                        in loop t
                        end
                in loop nodes
                end
            val nodes = get_nodes n "I"
            val _ = add_refs nodes
        in nodes
    end
    
    fun initiate_3_test_nodes () =
        let val node1 = initiate_node [] "1"
            val node2 = initiate_node [node1] "2"
            val node3 = initiate_node [node1, node2] "3"
            val _ = send(node1, ("ADD_NODES", [node2, node3]))
            val _ = send(node2, ("ADD_NODES", [node3]))
            val _ = send(node1, ("ELECTION-TIMEOUT", 1))
        in send(node2, ("ELECTION-TIMEOUT", 1))
    end
    val all_nodes = initiate_nodes 3
    val _ = sleep 5000
    val _ = send_to_all all_nodes ("SEND-MESSAGE", "Hello, World!") (self())
in ()
end