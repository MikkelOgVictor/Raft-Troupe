import lists
import stdio
import quickselect

(*
    Log = {
        snapshot: Snapshot
        log: Entry[],
        lastApplied: int,
        internalChanges: int,
        commitIndex: int,
        lastMessageSerial: string
    }
    Snapshot = {
        snapshot: Some state
        lastIncludedIndex: int,
        lastIncludedTerm: int
    }
    Entry = {
        term: int,
        command: message,
        serial: string
    }
*)

(*
    LeaderInfo = {
        nextIndex = {
            peer: p,
            next: int
        }[],
        matchIndex = {
            peer: p,
            match: int
        }[]
    }
*)

(*
    StateMachine = {
        set_hook : fn (x: string) => x
        get_hook : fn (x: string, callback_pid: string) => x
        get_state_hook : fn(callback_pid: string) => x
        get_changes_hook : fn (callback_pid: string) => x
        snapshot_condition_hook : fn (log_summary: LogSummary, callback_pid: string) => x: bool
    }
    LogSummary = {
        log_size: int,
        entries_since_snap: int
    }

*)

(*
    Node = {
        all_nodes: string[],
        id: string,
        log: Log,
        term: int,
        voted_for: string,
        leader: string,
        leader_info: LeaderInfo,
        state_machine: fn state => state_machine(state)
        empty_state: State,
        hooks: StateMachine,
        total_nodes: int,
        verbose: boolean
    }
*)


let 
    (* Constants *)
    val LOCAL_ERROR_TIMEOUT = 4000

    fun not a = a = false
    fun send_to_all processes msg sender = map (fn x => send(x, msg)) (filter (fn x => x <> sender) processes)

    fun send_to_nth processes msg n = send((nth (reverse processes) n), msg)

    fun max a b = if a < b then b else a 

    fun min a b = if a > b then b else a

    (* #IMPORT libs/log.trp *)
    (* Creates a snapshot *)
    fun set_snapshot snapshot index term = {
        snapshot = snapshot,
        lastIncludedIndex = index,
        lastIncludedTerm = term
    }

    (* Creates a default, empty snapshot *)
    val empty_snapshot = set_snapshot () 0 0

    (* A default, empty log*)
    val empty_log = {
        log = [],
        snapshot = empty_snapshot,
        lastApplied = 0,
        commitIndex = 0,
        internalChanges = 0,
        lastMessageSerial = ""
    }

    fun pretty_print_log id log = 
        printString "\n========******========";
        printString ("ID: "^id);
        printString "----------------------";
        printString "Entries (term, message):";
        map (fn x => print (x.term, x.command)) log.log;
        printString "----------------------";
        printString "CommitIndex:";
        print log.commitIndex;
        printString "LastApplied:";
        print log.lastApplied;
        printString "Internal Changes:";
        print log.internalChanges;
        printString "----------------------";
        printString "Snapshot:";
        print log.snapshot;
        printString "========******========\n"

    (* Appends a message to the log, and notes the message's serial number *)
    fun append_message log message term serial = 
        let val new_entry = {
            term = term,
            command = message,
            serial = serial
        }
        in {
            log with
            lastMessageSerial = serial, 
            log = new_entry :: log.log
        } 
    end


    (* Appends a list of message to the log *)
    fun add_entries_to_log log entries term =
        case entries of
        [] => log
        | h :: t => 
            add_entries_to_log (append_message log h.command term h.serial) t
            h.term

    fun update_applied_inner log = {
        log with
        lastApplied = log.lastApplied + 1,
        internalChanges = log.internalChanges - 1
    }

    (* Updates the lastApplied-index*)
    fun update_applied log = {
        log with
        lastApplied = log.lastApplied + 1
    }
    
    (* Commits a message in the log *)
    fun update_commit log new_index = {
       log with 
       commitIndex = (max new_index log.commitIndex)
    }

    (* Rolls the log back one entry*)
    fun rollback_log log =
        let val (_ :: prev_log) = log.log
    in {
        log with 
        log = prev_log
    }
    end
    
    (* Get the entry of the latest log entry *)
    fun get_log_index log = (length log.log) + log.snapshot.lastIncludedIndex

    (* Rolls the log back n time *)
    fun rollback_log_to log n = 
        if n < (get_log_index log) then
            let val log = rollback_log log
            in (rollback_log_to log n)
        end
        else log

    (* Get the term of the latest entry of the log, or, if empty, the last
    included index of the snapshot*)
    fun get_latest_entry_term log =
        case log.log of
        [] => log.snapshot.lastIncludedTerm
        | h :: _ => h.term

    fun get_latest_log_term log = get_latest_entry_term log

    fun get_latest_log_command log = 
        case log.log of
        [] => 0 (* Should not be reachable*)
        | h :: _ => h.command

    fun get_nth_command log index = nth (reverse log.log) (index - log.snapshot.lastIncludedIndex) 

    (* Returns a slice of all entries after log-index n *)
    fun get_commands_after_nth log n =
        let val log_slice = slice (n - log.snapshot.lastIncludedIndex) (length log.log) (reverse log.log)
        in log_slice
        end

    (* Returns a slice of all entries after the commit-index *)
    fun uncommitted_entries log = get_commands_after_nth log log.commitIndex

    (* Applies all log-entries that have been committed, but not applied *)
    fun apply_log log f = 
        let fun apply_internal log = let 
                val lastApplied = min (log.lastApplied + log.internalChanges) log.commitIndex
                val internalChanges = log.internalChanges - (lastApplied - log.lastApplied)
            in { log with lastApplied = lastApplied,
                        internalChanges = internalChanges} end

            fun apply_external log f = if log.lastApplied < log.commitIndex 
                    then 
                        let val _ = f ((get_nth_command log (log.lastApplied + 1)).command) 
                        val log = update_applied log
                        in apply_external log f end
                    else log

            val new_log = apply_external (apply_internal log) f
        in new_log
    end

    fun update_state state trans_func log =
        if log.lastApplied < log.commitIndex then
            let val command = (get_nth_command log (log.lastApplied + 1)).command
                val state = trans_func (state, command)
                val log = update_applied log
            in update_state state trans_func log end
        else (state, log)
    
    (* Receive a snapshot of the state-machine's current state *)
    fun take_snapshot state_machine_pid hooks index term = 
        let val p_id = self()
            val snapshot = 
                send (state_machine_pid, hooks.get_state_hook p_id);
                receive [
                    hn ("STATE_CALLBACK", state) => state
                ]
        in set_snapshot snapshot index term
    end

    (* Get a snapshot of all committed entries *)
    fun get_snapshot state_machine_pid hooks log = 
        if log.commitIndex > 0 andalso 
        (log.commitIndex - log.snapshot.lastIncludedIndex) <= length log.log then
            let val lastCommitted = get_nth_command log log.commitIndex
                val snapshot = take_snapshot state_machine_pid hooks log.commitIndex lastCommitted.term
            in snapshot end
        else empty_snapshot
        

    (* Applies a snapshot to the log *)
    fun apply_snapshot state_machine_pid snapshot log =
        let val uncommitted_entries = uncommitted_entries log
            val newCommitIndex =
                if log.commitIndex < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.commitIndex
            val newLastApplied =
                if log.lastApplied < snapshot.lastIncludedIndex then snapshot.lastIncludedIndex
                else log.lastApplied
        in { log with 
                log = uncommitted_entries,
                commitIndex = newCommitIndex,
                lastApplied = newLastApplied,
                snapshot = snapshot }
    end

    (* Generates a summary of the log containing the amount of committed
    entries, and the number of entries since the last Snapshot *)
    fun generate_summary log = 
        {applied_log_size = log.lastApplied, 
            entries_since_snap = (log.lastApplied - log.snapshot.lastIncludedIndex)}

    (* Asks the state-machine whether or not to snapshot *)
    fun evaluate_snapshot_cond state_machine_pid hooks log = 
        if log.internalChanges > 0 then log
        else 
            let val p_id = self ()
                val summary = generate_summary log
            in 
                send(state_machine_pid, (hooks.snapshot_condition_hook (summary, p_id)));
                receive [
                    hn ("SNAPSHOT_CALLBACK", callback) => 
                        if callback then apply_snapshot state_machine_pid (get_snapshot state_machine_pid hooks log) log
                        else log
                ]
        end
    
    fun prepend_internal_change changes node_term log = 
        let val insert_index = log.internalChanges + log.commitIndex - log.snapshot.lastIncludedIndex
            val term = if insert_index < (length log.log) then (get_nth_command log insert_index).term else node_term
            val change_entries = map (fn change => { term = term, command = change, serial = 0}) changes
            val entries = append_at_index (reverse log.log) change_entries insert_index 
        in { log with log = reverse entries,
                internalChanges = log.internalChanges + (length changes)}
    end

    fun add_internal_changes state_machine_pid hooks node_term log =
        let val p_id = self ()
            val changes =
                send(state_machine_pid, hooks.get_changes_hook p_id);
                receive [
                    hn ("CHANGES_CALLBACK", callback) => callback
                ]
        in 
            case changes of
            [] => log
            | h :: t => prepend_internal_change (h :: t) node_term log
            | _ => printString "ERROR: Changes should be a list of messages"; log
    end

    fun get_startup_log_state_pair (fallback_state, log)  =
        if log.snapshot.snapshot = () then 
            (fallback_state, { log with lastApplied = 0 })
        else 
            (log.snapshot.snapshot, { log with lastApplied = log.snapshot.lastIncludedIndex})
        

    (* END OF libs/log.trp *)

    (* #IMPORT libs/state_machines/key-val.trp *)
    fun key_val_store dic = 
        let fun remove element list = 
            case list of 
            [] => []
            | h :: t => 
                if h = element then t
                else append [h] (remove element t)
        fun get_record key dic =
            case dic of
                [] => ()
                | h :: t => 
                    if h.key = key then h
                    else get_record key t
        fun get key dic = 
            let val record = get_record key dic
            in if record = () then ()
                else record.value
            end
        fun set (key, value) dic = 
            let val existing_record = get_record key dic 
                val new_record = {key = key, value = value}
            in if existing_record = () then 
                append [{key = key, value = value}] dic
            else 
                if new_record = existing_record then dic
                else append [new_record] (remove existing_record dic)
            end
        fun drop key dic = 
            remove (get_record key dic) dic
        fun loop dic = 
            let val dic = receive [
                hn ("SET", (key, value)) => set (key, value) dic,

                hn ("GET", (key, sender_id)) => 
                    send(sender_id, ("RESPONSE", (get key dic)));
                    dic,
                hn ("GET_STATE", sender_id) => 
                    send(sender_id, ("SNAPSHOT", dic));
                    dic,

                hn ("SNAPSHOT_CONDITION", (log_summary, sender_id)) => 
                    let val callback = log_summary.applied_log_size > (length dic) 
                        andalso log_summary.entries_since_snap > 50
                    in 
                        send(sender_id, ("SNAPSHOT_CALLBACK", callback));
                        dic end,
                
                hn ("GET_CHANGES", callback_pid) =>
                    send(callback_pid, ("CHANGES_CALLBACK", []));
                    dic,

                hn ("DROP", key) => drop key dic
            ]
            in loop dic
            end
        in loop dic
    end

    val key_val_store_hooks = 
        {sethook = (fn x => case x of (key, value) => ("SET", (key, value))), 
            gethook = (fn (x, callback_pid) => ("GET", (x, callback_pid))), 
            get_state_hook = (fn (callback_pid) => ("GET_STATE", callback_pid)),
            get_changes_hook = (fn callback_pid => ("GET_CHANGES", callback_pid)),
            snapshot_condition_hook = (fn (log_summary, callback_pid) => ("SNAPSHOT_CONDITION", (log_summary, callback_pid)))}
    (* END OF libs/state_machines/key-val.trp *)

    (* #IMPORT libs/state_machines/counter.trp *)
    fun countdown_after_n n callback_id nonce = 
        sleep (n);
        send(callback_id, ("COUNTDOWN_END", nonce))

    fun counter count changes = 
        let val nonce = mkuuid()
            val p_id = self()
            fun loop changes =
                receive [
                    hn ("COUNTDOWN_END", x) when nonce = x => 
                        counter (count + 1) (append changes [("INCREMENT")]),

                    hn ("INCREMENT") => counter (count + 1) changes,

                    hn ("SET", x) => counter x changes,

                    hn ("GET", callback_pid) => send(callback_pid, count); loop changes,
                    
                    hn ("SNAP_COND", (summary, callback_pid)) => 
                        let val callback = summary.entries_since_snap > 9 andalso count > 10
                        in 
                            send(callback_pid, ("SNAPSHOT_CALLBACK", callback));
                            loop changes end,

                    hn ("GET_STATE", callback_pid) =>
                        send(callback_pid, ("STATE_CALLBACK", count));
                        loop changes,

                    hn ("GET_CHANGES", callback_pid) => 
                        send(callback_pid, ("CHANGES_CALLBACK", changes));
                        loop [],

                    hn ("SHUTDOWN") => (),

                    hn _ => loop changes
                ]
        in spawn(fn () => countdown_after_n 500 p_id nonce);
        loop changes
    end

    val counter_hooks = 
        {sethook = (fn x => ("SET", x)), 
            gethook = (fn (x, callback_pid) => ("GET", callback_pid)), 
            get_state_hook = (fn callback_pid => ("GET_STATE", callback_pid)),
            get_changes_hook = (fn callback_pid => ("GET_CHANGES", callback_pid)),
            snapshot_condition_hook = (fn (log_summary, callback_pid) => ("SNAP_COND", (log_summary, callback_pid)))}
(* END OF libs/state_machines/counter.trp *)

    (* #IMPORT libs/leader-info.trp *)

    (* Generates a default leader info, with the nextIndex of all followers
    being the nextIndex of the new leader. This can be changed with followers
    rejecting AppendEntries *)
    fun new_leader all_nodes log = 
        let val nextIndex = get_log_index log
            val index = map (fn id => {peer = id, next = nextIndex + 1}) all_nodes
            val match_index = map (fn id => {peer = id, match = 0}) all_nodes
        in {
            nextIndex = index,
            matchIndex = match_index
        } end
    
    (* Get the nextIndex of a peer *)
    fun get_next_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.nextIndex)

    (* Get the matchIndex of a peer *)
    fun get_match_index leader_info peer = first (filter (fn (x) => x.peer = peer) leader_info.matchIndex)

    fun update_next_index leader_info peer new = let
        val prevIndex = get_next_index leader_info peer
        val newIndex = {peer = peer, next = new}
        val withoutPeer = filter (fn (x) => x.peer <> peer) leader_info.nextIndex
    in {
        leader_info with 
        nextIndex = newIndex :: withoutPeer
    } end

    fun update_match_index leader_info peer new = let
        val prevIndex = get_match_index leader_info peer
        val newIndex = {peer = peer, match = new}
        val witoutPeer = filter (fn (x) => x.peer <> peer) leader_info.matchIndex
    in {
        leader_info with 
        matchIndex = newIndex :: witoutPeer
    } end

    (* Get all follower's matchIndex*)
    fun get_matches leader_info = map (fn x => x.match) leader_info.matchIndex

    (* Get the highest index of entries that a majority of followers have
    appended to, by finding the median *)
    fun calc_highest_commit matches = median matches
    (* END OF libs/leader-info.trp *)

    fun verbose_print x verbose = if verbose then print x else ()

    (* Executes a function after a given timeout *)
    fun start_timeout func duration = 
        let fun timeout () = 
            let val time = duration
                val _ = sleep time
            in func ()
            end
            val p_id = self()
        in spawn timeout
    end

    fun err_timeout func default = 
        let val p_id = self()
            val nonce = mkuuid()
        in 
            start_timeout (fn () => send(p_id, ("ERROR_TIMEOUT", nonce))) LOCAL_ERROR_TIMEOUT;
            spawn (fn () => 
                let val x = func ()
                in send(p_id, ("FUNCTION_DONE", nonce, x)) end);
            receive [
                hn ("ERROR_TIMEOUT", x) when x = nonce => 
                    printString "==========================";
                    printString "Timeout-Error on func:";
                    print func;
                    printString "Trying to recover, but there may be an error here";
                    printString "==========================";
                    (* TODO: THIS IS WHERE A THREAD MUST BE KILLED *)
                    default,
                hn ("FUNCTION_DONE", x, output) when x = nonce =>
                    output
            ]
    end

    (* Starts a random timeout with lower=2sec and upper=4sec *)
    fun start_random_timeout func = start_timeout func (2000 + ((random ()) * 2000))
    
    fun leader_node node state_machine_pid = 
        let val p_id = self()
            (* Appends appends all entries from a follower's nextIndex to the leader's log index*)
            fun append_entries follower_pid =
                    let val nextIndex = get_next_index node.leader_info follower_pid
                    val logIndex = get_log_index node.log
                in if logIndex + 1 >= nextIndex.next then 
                    let 
                        val latestLogIndex = nextIndex.next - 1
                    in 
                        (* Sends the snapshot if the followers nextIndex is before the Snapshot's lastIncludedIndex *)
                        if nextIndex.next <= node.log.snapshot.lastIncludedIndex 
                            then send(follower_pid, ("Snapshot", node.log.snapshot, p_id, node.term))
                        else 
                            let val entries = get_commands_after_nth node.log latestLogIndex
                                val afterSnapshot = latestLogIndex - node.log.snapshot.lastIncludedIndex
                                val prevEntryTerm = 
                                    if afterSnapshot > 0 then (get_nth_command node.log latestLogIndex).term 
                                    else node.log.snapshot.lastIncludedTerm
                            in send(follower_pid, ("AppendEntries", entries, p_id, node.term, latestLogIndex, prevEntryTerm, node.log.commitIndex))
                        end
                end
                (* A follower should never get more entries than the leader *)
                else print "ERROR"
            end

            (* Convert leader to follower *)
            fun demote term leader voted_for node = 
                (* Kill-function needed here to destroy state-machine, temporary solution *)
                send(state_machine_pid, "SHUTDOWN");
                {node with 
                    term = term, 
                    leader = leader,
                    leader_info = (),
                    voted_for = voted_for}

            (* Applies all committed nodes that have not already been applied *)
            fun apply_committed node = 
                let val prev_commit = node.log.commitIndex
                    val highest_commit = calc_highest_commit (map (fn x => x.match) node.leader_info.matchIndex)
                    val node = { node with log = update_commit node.log highest_commit }
                    val applied_log = apply_log node.log (fn x => send(state_machine_pid, x))
                    val snapshot_log = 
                        if prev_commit < highest_commit then 
                            evaluate_snapshot_cond state_machine_pid node.hooks applied_log 
                        else 
                            applied_log
                in { node with log = snapshot_log }
            end
                
            val nonce = mkuuid ()
            
            fun loop node =
                receive [
                    hn ("SEND_HEARTBEAT", x) when nonce = x =>
                        let val log = 
                            verbose_print (node.id^": Sending heartbeat") node.verbose;
                            err_timeout (fn () => add_internal_changes state_machine_pid node.hooks node.term node.log) node.log 
                        in 
                            
                            leader_node ({node with log = log}) state_machine_pid end,

                    (* Message has already been received and appended *)
                    hn (("RAFT-UPDATE", x), dialer_id, serial_n) when serial_n = node.log.lastMessageSerial =>
                        send(dialer_id, "DIALER-ACK");
                        loop node,

                    (* Message has not been appended before *)
                    hn (("RAFT-UPDATE", x), dialer_id, serial_n) => 
                        let val latestLogIndex = get_log_index node.log
                            val prevLogTerm = get_latest_log_term node.log
                            val log = append_message node.log (node.hooks.sethook x) node.term serial_n
                            val leader_info = update_match_index node.leader_info p_id (get_log_index log)
                            val leader_info = update_next_index leader_info p_id ((get_log_index log) + 1)
                            val node = {node with log = log, leader_info = leader_info}
                        in 
                            verbose_print (node.id^": Appending new message to log") node.verbose;
                            send(dialer_id, "DIALER-ACK");
                            loop node end,

                    hn (("RAFT-GET", x), dialer_id) =>
                        send (state_machine_pid, (node.hooks.gethook x));
                        send(dialer_id, "DIALER-ACK");
                        loop node,

                    (* If append is successful on a follower*)
                    hn ("ACKNOWLEGDE", (peer, logIndex)) => 
                        let val node = { node with leader_info = update_match_index node.leader_info peer logIndex }
                            val node = { node with leader_info = update_next_index node.leader_info peer (logIndex + 1) }
                        in loop (apply_committed node) end,
                    
                    (* If append is unsuccessful *)
                    hn ("REJECT", (peer, terminfo, logIndex)) => 
                        if node.term >= terminfo.term then 
                            let val node = { node with leader_info = update_next_index node.leader_info peer ((min (get_log_index node.log) (logIndex)) + 1) } 
                            in loop node 
                            end
                        else follower (demote terminfo.term terminfo.leader ()
                        node),

                    (* If another node has been elected as a candidate, and
                        their term is in front of ours, convert to a follower *)
                    hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term)) when c_term > node.term =>
                        verbose_print (node.id^": Voting yes") node.verbose;
                        send(c_id, ("YES-VOTE", node.id));
                        follower (demote c_term () c_id node),

                    hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term)) =>
                        send(c_id, ("NO-VOTE", node.id));
                        loop node,

                    (* If we receive snapshot from a leader in a higher term,
                    convert to follower *)
                    hn ("Snapshot", snapshot, l_id, other_term) when other_term > node.term =>
                        let val _ = verbose_print (node.id^": received Snapshot from leader, I must have lost position") node.verbose
                        in follower (demote other_term l_id () node)
                        end,
                    
                    (* If we receive AppendEntries from a leader in a higher term,
                    convert to follower *)
                    hn ("AppendEntries", x, l_id, other_term, prevIndex, prevTerm, commitIndex) when other_term > node.term => 
                        verbose_print (node.id^": received AppendEntries from leader, I must have lost position") node.verbose;
                        follower (demote other_term l_id () node),
                    
                    (* Prints log *)
                    hn ("debug-printlog") =>
                        pretty_print_log node.id node.log;
                        print node.leader_info;
                        loop node,

                    (* Halts the leader *)
                    hn ("debug-pause") =>
                        let fun pause () = receive [
                            hn ("debug-continue") => loop node,
                            hn x => pause ()
                        ]
                        in pause () end,

                    (* Applies a snapshot *)
                    hn ("debug-applysnapshot") =>
                        let 
                            val snapshot = get_snapshot state_machine_pid node.state node.hooks node.log
                            val node = case snapshot.snapshot of
                            () => node
                            | _ => {node with log = apply_snapshot state_machine_pid snapshot node.log}
                        in 
                            verbose_print (node.id^": applying snapshot") node.verbose;
                            loop node end,

                    (* Asks the state-machine for the snapshot condition *)
                    hn ("debug-snapshotcond") =>
                        print (evaluate_snapshot_cond state_machine_pid node.state node.hooks node.log);
                        loop node,
                    hn _ => loop node
                ]
        in 
            (* Append entries for each follower *)
            map (fn x => append_entries x) (filter (fn x => x <> p_id) node.all_nodes);
            start_timeout (fn () => send (p_id, ("SEND_HEARTBEAT", nonce))) 500;
            loop node
    end

    and candidate node =
        let val p_id = self()

            (* A candidate cannot vote for anyone and has no leader *)
            val node = {node with voted_for = (), leader = ()}
            val nonce = mkuuid()

            (* Sends a vote request to all followers *)
            val latestLogIndex = get_log_index node.log
            val prevLogTerm = get_latest_log_term node.log
            

            (* Becoming a leader requires majority vote *)
            val req_votes = ((length node.all_nodes) / 2)
            
            fun won_election () = 
                let val (starting_state, log) = get_startup_log_state_pair (node.empty_state, node.log)
                    val state_machine_pid = spawn(fn () => node.state_machine starting_state)
                    val applied_log = apply_log log (fn x => send(state_machine_pid, x))
                in
                    verbose_print (node.id^": I won the election") node.verbose;
                    leader_node ({ 
                        node with leader_info = (new_leader node.all_nodes node.log),
                        leader = p_id,
                        log = applied_log}) state_machine_pid
            end
            
            fun wait_for_votes (follower_votes, vote_amount) = 
                let 
                    fun loop () = receive [
                    (* Received a vote from a follower we have not already
                    received a vote from *)
                    hn ("YES-VOTE", follower_id) when (not (contains follower_id follower_votes)) => 
                        wait_for_votes ((append follower_votes [follower_id]), vote_amount + 1),

                    (*We received a no-vote from a follower in a later term.
                    This can only happen if there is a leader/candidate in this
                    term, and as such, we convert to a follower *)
                    hn ("NO-VOTE", other_term) when other_term > node.term =>
                        follower node,

                    (* Received vote request from leader in later term *)
                    hn ("RequestVote", (c_term, other_c_id, c_log_index, c_log_term)) when c_term > node.term =>
                        let val _ = send(other_c_id, ("YES-VOTE", node.id))
                        in follower ({ node with term = c_term, voted_for = other_c_id})
                        end,
                    
                    (* Received message from leader in a term at least as
                    up-to-date as ours. Because of this, we must have lost the
                    election *)
                    hn ("AppendEntries", x, l_id, other_term, prevIndex, prevTerm, commitIndex) when other_term >= node.term => 
                        let val _ = verbose_print (node.id^": received AppendEntries from leader, I must have lost position") node.verbose
                        in follower ({ node with leader = l_id})
                        end,

                    (* Election timeout, send out another request vote *)
                    hn ("VOTE-TIMEOUT", x) when x = nonce => candidate {node with term = node.term + 1},

                    (* Halts the candidate *)
                    hn ("debug-pause") =>
                        let fun loop () = receive [
                            hn ("debug-continue") => (),
                            hn x => loop ()
                        ]
                        in loop () end,
                    hn _ => loop ()
                ]
                in if vote_amount >= req_votes then won_election () else loop ()
            end
        in 
            verbose_print (node.id^": I am now a candidate") node.verbose;
            send_to_all node.all_nodes ("RequestVote", (node.term, p_id, latestLogIndex, prevLogTerm)) (p_id);
            start_random_timeout (fn () => send(p_id, ("VOTE-TIMEOUT", nonce)));
            wait_for_votes ([node.id], 1) 
    end
    
    and follower node = 
        let val p_id = self()
            val nonce = mkuuid()
            val _ = start_random_timeout (fn () => send(p_id, ("ELECTION-TIMEOUT", nonce)))
            
            (* Sends a yes-vote to a candidate *)
            fun vote_for c_id c_term node = 
                send(c_id, ("YES-VOTE", node.id));
                { node with term = c_term, voted_for = c_id } 
            fun loop node = let
                fun start_election () =
                    let val _ = verbose_print (node.id^": START ELECTION") node.verbose
                    in candidate ({node with term = node.term + 1})
                    end
                val _ = receive [
                    (* Starts an election *)
                    hn ("ELECTION-TIMEOUT", x) when x = nonce => start_election (),

                    (* Sends a re-vote to a candidate we already voted for *)
                    hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term)) when c_id = node.voted_for =>
                        verbose_print (node.id^": Voting yes") node.verbose;
                        follower (vote_for c_id c_term node),
                    
                    (* If we receive a vote request, vote yes if: the log is a
                    up-to-date and the term of the candidate is later than our
                    current. Vote no otherwise *)
                    hn ("RequestVote", (c_term, c_id, c_log_index, c_log_term)) =>
                        let val latestLogIndex = get_log_index node.log
                            val latestLogTerm = get_latest_log_term node.log
                            fun no_vote () =
                                send(c_id, "NO-VOTE");
                                verbose_print (node.id^":voting no") node.verbose;
                                follower node
                            fun yes_vote () =
                                verbose_print (node.id^": Voting yes") node.verbose;
                                follower (vote_for c_id c_term node)
                        in 
                            if latestLogIndex > c_log_index then no_vote ()
                            else if latestLogTerm > c_log_term then no_vote ()
                            else if c_term <= node.term then no_vote ()
                            else yes_vote ()
                        end,

                    (* When receiving a snapshot from a leader in a later or
                    same term, acknowledge if it contains entries past our
                    current log index. Update leader and term accordingly. *) 
                    hn ("Snapshot", x, l_id, leader_term) => 
                        let val node = {node with leader = 
                                if node.leader = () orelse node.term < leader_term then l_id 
                                else node.leader} 

                            val {snapshot, lastIncludedIndex, lastIncludedTerm} = x 
                            val log_term = get_latest_log_term node.log 
                            val log_index = get_log_index node.log

                            val accepting = 
                                if leader_term < node.term then false
                                else if lastIncludedIndex <= log_index then false
                                else true

                            val newlog = if accepting then apply_snapshot node.state_machine_pid x node.log else node.log
                            val reject = fn () => send (l_id, ("REJECT", (p_id, {term = term, leader = leader}, (get_log_index newlog))))
                            val ack = fn () => send (l_id, ("ACKNOWLEGDE", (p_id, get_log_index newlog)))

                            val newlog = if accepting then apply_snapshot node.state_machine_pid x node.log else node.log
                            val reject = 
                                fn () => send (l_id, ("REJECT", (p_id, {term = node.term, leader = node.leader}, (get_log_index newlog))))
                            val ack = 
                                fn () => send (l_id, ("ACKNOWLEGDE", (p_id, get_log_index newlog)))

                            val node = {node with term = (if node.term < leader_term then leader_term else node.term)}
                            
                        in 
                            (if accepting then ack ()
                                    else reject ());
                            follower {node with log = newlog}
                        end,

                    (* When receiving entries from a leader in a later or
                    same term, acknowledge if it contains entries past our
                    current log index. And if the latest log index matches ours.
                    Update log accordingly.*)
                    hn ("AppendEntries", x, l_id, leader_term, latestLogIndex, prevLogTerm, leaderCommit) => 
                        let val node = {node with leader = 
                                if node.leader = () orelse node.term <= leader_term then l_id
                                else node.leader}
                            val accepting = 
                                if leader_term < node.term then false
                                else if latestLogIndex > (get_log_index node.log) then 
                                    false
                                else if (get_latest_log_term node.log) <> prevLogTerm andalso prevLogTerm > 0 then 
                                    false
                                else true
                            val newlog = 
                                if accepting then
                                    let val log = rollback_log_to node.log latestLogIndex
                                        val log = add_entries_to_log log x leader_term
                                    in update_commit log (min leaderCommit (get_log_index log)) 
                                    end
                                else node.log
                            val reject = 
                                fn () => send (l_id, ("REJECT", (p_id, {term = node.term, leader = node.leader}, (get_log_index newlog))))
                            val ack = 
                                fn () => send (l_id, ("ACKNOWLEGDE", (p_id, get_log_index newlog)))

                            val node = {node with term = (if node.term < leader_term then leader_term else node.term)}
                            val _ = if accepting then ack ()
                                    else 
                                        let val _ = verbose_print (node.id^": REJECTING") node.verbose
                                        in reject ()
                                        end
                        in follower {node with log = newlog}
                        end,

                    (* If client sends update, sends the leader's id *)
                    hn (("RAFT-UPDATE", x), dialer_id, serial_n) => 
                        send(dialer_id, ("NOT-LEADER", node.leader)),
                    
                    (* If client sends get, send the leader's id*)
                    hn (("RAFT-GET", x), dialer_id) => 
                        send(dialer_id, ("NOT-LEADER", node.leader, x)),

                    (* Prints the log *)
                    hn ("debug-printlog") =>
                        pretty_print_log node.id node.log,

                    (* Halts the follower *)
                    hn ("debug-pause") =>
                        let fun loop () = receive [
                            hn ("debug-continue") => (),
                            hn x => loop ()
                        ]
                        in loop () end,

                    (* Start an election, electing this follower to a candidate
                    *)
                    hn ("debug-timeout") => start_election (),
                    hn _ => 
                        loop node
            ]
            in loop node
        end
        in loop node
    end

    fun dormant_node node =
        if length(node.all_nodes) < node.node_amount then
            receive [
                (* Adds a node to the cluster, only used for initialization *)
                hn ("ADD_NODES", x) => 
                    dormant_node ({node with all_nodes = append node.all_nodes x})
            ]
        else follower node
    
    (* Defines a default node, being a follower in term 1 without a leader and
    the state-machine in its beginning state *)
    fun default_node id all_nodes node_amount state_machine init_state hooks verbose = 
        let val node = {
            all_nodes = all_nodes,
            id = id,
            log = empty_log,
            term = 1,
            voted_for = (),
            leader = (),
            leader_info = (),
            state_machine = state_machine,
            empty_state = init_state,
            hooks = hooks,
            node_amount = node_amount,
            verbose = verbose
        }
        in fn() => printString (id^": Starting node..."); dormant_node node
    end

    (* Spawn a state-machine on a seperate thread, creates a record*)
    fun initiate_node state_machine init_state hooks node_amount id verbose = 
        spawn (default_node id [] node_amount state_machine init_state hooks verbose)

    (* Sends a list of all nodes to all nodes *)
    fun add_refs nodes = 
        map (fn x => send(x, ("ADD_NODES", nodes))) nodes
    
    (* Spawn n nodes*)
    fun initiate_nodes n state_machine init_state hooks verbose =
        let val part_init = initiate_node state_machine init_state hooks n
            fun spawn_nodes n acc_id =
                case n of
                0 => []
                | x => append 
                    (spawn_nodes (x - 1) (acc_id ^ "I")) 
                    [(part_init acc_id verbose)]

            val nodes = spawn_nodes n "I"
        in 
            add_refs nodes;
            nodes
    end

    (* Spawn a state-machine on some alias *)
    fun initiate_distributed_node state_machine init_state hooks node_amount id alias verbose = 
        spawn(alias, (default_node id [] state_machine init_state hooks node_amount verbose))

    fun initiate_distributed_nodes aliases state_machine init_state hooks verbose =
        let val part_init = initiate_distributed_node state_machine init_state hooks (length(aliases))
            fun spawn_nodes acc acc_id =
                case acc of 
                [] => []
                | h :: t =>
                    append (spawn_nodes t (acc_id ^ "I")) [part_init acc_id h verbose]
            val nodes = spawn_nodes aliases "I"
        in 
            add_refs nodes;
            nodes
    end
                    
    (* Facilitates client-side interaction to the Raft cluster *)
    fun dialer cluster = 
        let val p_id = self()
            fun random_leader () =
                let fun roundUp n m = 
                        if n <= 0 then m else roundUp (n - 1) (m + 1)
                    val r_n = roundUp (random() * (length cluster - 1)) 0 
                in nth cluster r_n
            end
            val leader = random_leader ()

            fun send_message msg leader = let 
                val nonce = mkuuid()
                val msg_timeout = start_timeout (fn() => send(p_id, ("MESSAGE-TIMEOUT", nonce)))
                fun wait () =
                    receive [
                    hn ("NOT-LEADER", leader_id) => 
                        send_message msg leader_id,
                    hn ("DIALER-ACK") => leader,
                    hn ("MESSAGE-TIMEOUT", x) => 
                        if x = nonce then send_message msg (random_leader ())
                        else wait ()
                ]
                in
                    (case leader of
                    () => msg_timeout 500
                    | x =>                         
                        msg_timeout 2000; 
                        send(x, msg));
                    wait ()
            end

            fun update_message x leader = let 
                val serial_n = mkuuid()
                in send_message (("RAFT-UPDATE", x), p_id, serial_n) leader
            end

            fun get_message x leader = send_message (("RAFT-GET", x), p_id) leader


            fun loop leader =     
                let val leader = receive [
                    hn ("RAFT-UPDATE", x) =>
                        update_message x leader,

                    hn ("RAFT-GET", x) =>
                        get_message x leader,

                    hn ("SEND-TO-NTH", n, x) =>
                        send_to_nth cluster x n;
                        leader,

                    hn ("SEND-TO-ALL", x) => 
                        send_to_all cluster x (self());
                        leader,
                    hn x => leader ]
                in loop leader end
        in loop leader
    end

    (* Spawns a distributed Raft network, and a dialer, which can be contacted to
    communicate with their state-machines *)
    fun raft_d aliases state_machine init_state hooks verbose =
        let val nodes = initiate_distributed_nodes aliases state_machine init_state hooks verbose
        in spawn (fn () => dialer nodes)
    end

    (* Spawns a Raft network, and a dialer, which can be contacted to
    communicate with their state-machines *)
    fun raft n state_machine init_state hooks verbose =
        let val nodes = initiate_nodes n state_machine init_state hooks verbose
        in spawn (fn () => dialer nodes)
    end

    (* #IMPORT libs/tests/key-val-tests.trp *)
    fun send_delay (to, m) delay =
        sleep delay;
        send (to, m)

    fun send_n_updates raft n =
        let fun loop n =
            send(raft, ("RAFT-UPDATE", ("TEST", "TEST")));
            print n;
            sleep 10;
            if n > 1 then loop (n - 1) else () 
        in loop n 
    end

    fun send_n_unique_updates raft n =
        let fun loop n =
            send(raft, ("RAFT-UPDATE", (mkuuid(), "TEST")));
            print n;
            sleep 10;
            if n > 1 then loop (n - 1) else ()
        in loop n
    end

    fun assert_equals a b =
        if a = b then ()
        else print "Assertion Error, expected"; print a; print "Actual:"; print b

    fun keyval_test1 raft_func = 
        let val raft = raft_func ()
        in
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 500;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-pause")) 1000;
            print "killing I";
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "World"))) 500;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-continue")) 8000;
            print "reviving I";
            send(raft, ("SEND-TO-NTH", 1, ("RAFT-UPDATE", ("Hello", "Other World"))));
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 2000
    end

    fun keyval_test2 raft_func = 
        let val raft = raft_func ()
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send(raft, ("SEND-TO-NTH", 2, "debug-timeout"));
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 1000
    end

    fun keyval_test3 raft_func = 
        let val p_id = self()
            val raft = raft_func ()
        in 
            send_delay(raft, ("RAFT-UPDATE", ("A", 42))) 2000;
            send_delay(raft, ("RAFT-GET", ("A", p_id))) 1000;
            receive [hn x => print x]
    end

    fun keyval_test4 raft_func = 
        let val raft = raft_func ()
        in
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 2000;
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 1000;
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 1000;
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 1000;
            send_delay(raft, ("RAFT-UPDATE", ("Hello", "There"))) 1000;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 4000
    end

    fun keyval_test5 raft_func =
        let val raft = raft_func ()
        in
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_n_updates raft 51;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 5000
    end

    fun keyval_test6 raft_func = 
        let val raft = raft_func ()
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_delay(raft, ("RAFT-UPDATE", ("A", 2))) 1000;
            send_delay(raft, ("RAFT-UPDATE", ("A", 3))) 500;
            send_delay(raft, ("RAFT-UPDATE", ("A", 4))) 10;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 5000
    end

    fun keyval_test_snapshot raft_func =
        let val raft = raft_func ()
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_delay(raft, ("SEND-TO-NTH", 3, "debug-pause")) 100;
            print "sending 1";
            send(raft, ("RAFT-UPDATE", ("A", 1)));
            print "sending 2";
            send_delay(raft, ("RAFT-UPDATE", ("A", 2))) 50;
            print "sending 3";
            send_delay(raft, ("RAFT-UPDATE", ("A", 4))) 50;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-printlog")) 1000;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-applysnapshot")) 5000;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-printlog")) 1000
    end

    fun keyval_test_lots_of_messages raft_func = 
        let val raft = raft_func ()
        in 
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            sleep 1000;
            send_n_updates raft 1000;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 5000
    end

    fun keyval_test_lots_of_unique_messages raft_func = 
        let val raft = raft_func ()
        in
            sleep 5000;
            send_n_unique_updates raft 1000;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 1000
    end

    (* Application of the local Raft algorithm on a key-value-store*)
    fun key_val_store_init n verbose = raft n key_val_store [] key_val_store_hooks verbose
    (* Application of the distributed Raft algorithm on a key-value-store*)
    fun key_val_store_init_d aliases verbose = raft_d aliases key_val_store [] key_val_store_hooks verbose


    (* END OF libs/tests/key-val-tests.trp *)
    (* #IMPORT libs/tests/counter-tests.trp *)
    fun counter_init n verbose = raft n (fn state => counter state []) 0 counter_hooks verbose
    fun counter_test1 () =
        let val raft = counter_init 5 true
            val p_id = self()
        in
            send(raft, ("SEND-TO-NTH", 1, "debug-timeout"));
            send_delay(raft, ("RAFT-UPDATE", 10)) 2000;
            send_delay(raft, ("SEND-TO-NTH", 2, "debug-timeout")) 500;
            send_delay(raft, ("SEND-TO-NTH", 1, "debug-timeout")) 2000;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 2000;
            send_delay(raft, ("SEND-TO-ALL", "debug-printlog")) 2000
    end
    (* END OF libs/tests/counter-tests.trp *)

    val default_aliases = ["@node1", "@node2", "@node3"]

in keyval_test1 (fn () => key_val_store_init 5 true)
end
